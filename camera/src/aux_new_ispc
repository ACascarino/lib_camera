// Copyright 2023 XMOS LIMITED.
// This Software is subject to the terms of the XMOS Public Licence: Version 1.

#include <stdio.h>

#include <stdint.h>
#include <stdio.h>

#include <xcore/assert.h>
#include <xcore/channel.h> // includes streaming channel and channend
#include <xccompat.h>

#include "sensor_control.h"
#include "print.h"

#include "new_isp.h"

isp_params_t isp_params = {
  .channel_gain = {
  AWB_gain_RED,
  AWB_gain_GREEN,
  AWB_gain_BLUE
  }
};

void isp_pipeline(
  const int8_t pixel_data[CH][W],
  const unsigned row_index,
  chanend c_control)
{
  unsigned start = measure_time();

  // Constants definitions
  const size_t img_size = W*H;
  const size_t row_size = W;
  const float inv_img_size = 1.0f / img_size;
  const float inv_row_size = 1.0f / row_size;

  // Histogram
  static histograms_t histograms;
  static statistics_t statistics;
  if (row_index == 0){
    memset(&histograms, 0, sizeof(histograms_t));
    memset(&statistics, 0, sizeof(statistics_t));
  }

  // Histogram
  compute_hist(&histograms.histogram_red,   &pixel_data[0][0], row_size);
  compute_hist(&histograms.histogram_green, &pixel_data[1][0], row_size);
  compute_hist(&histograms.histogram_blue,  &pixel_data[2][0], row_size);
  
  // End of frame operations
  if(row_index == (H - 1)){
      // Stats: (min, max, mean)
      stats_simple(&histograms.histogram_red,   &statistics.stats_red,   inv_img_size);
      stats_simple(&histograms.histogram_green, &statistics.stats_green, inv_img_size);
      stats_simple(&histograms.histogram_blue,  &statistics.stats_blue,  inv_img_size);

      // Stats: (skewness)
      stats_skewness(&histograms.histogram_red,   &statistics.stats_red,   inv_img_size);
      stats_skewness(&histograms.histogram_green, &statistics.stats_green, inv_img_size);
      stats_skewness(&histograms.histogram_blue,  &statistics.stats_blue,  inv_img_size);

      // AE control exposure
      uint8_t ae_done = AE_control_exposure(&statistics, c_control);

      // Adjust AWB
      static unsigned run_once = 0;
      if (ae_done == 1 && run_once == 0) 
      {
        AWB_compute_gains_static(&isp_params);
        run_once = 1; // Set to 1 to run only once
      }
  }

  // Time measure
  unsigned end = measure_time();
  printf(">%d\n", end - start);
}


// ---------------------------------- Stats ------------------------------

void compute_hist(channel_histogram_t* hist,const int8_t* pix, const uint32_t pixel_size)
{
  int16_t val = 0;
  for(uint32_t k = 0; k < pixel_size; k ++){
    val = pix[k];
    val += 128; // convert from int8_t to uint8_t
    val >>= HIST_QUANT_BITS;
    hist->bins[val]++;
  }
}

void stats_simple(channel_histogram_t* histogram, channel_stats_t* stats, const float inv_pix_size)
{
  // Calculate the histogram
  uint8_t temp_min = 0;
  uint8_t temp_max = 0;
  float temp_mean  = 0;

  for(int k = 0; k < HISTOGRAM_BIN_COUNT; k++){
    uint32_t bin_count = histogram->bins[k];
    // mean
    temp_mean += bin_count * k;
    // max and min
    if (bin_count != 0){  // the last that is not zero
      temp_max = k;
      if (temp_min == 0){ // first time is zero, then min is set
        temp_min = k;
      }
    }
  }
  // max and min count
  stats->max_count = histogram->bins[temp_max];
  stats->min_count = histogram->bins[temp_min];

  // biased downwards due to truncation
  stats->max = (temp_max << HIST_QUANT_BITS);
  stats->min = (temp_min << HIST_QUANT_BITS);
  stats->mean = (temp_mean) * inv_pix_size;
}

void stats_skewness(channel_histogram_t* histogram, channel_stats_t* stats, const float inv_pix_size)
{
  const float zk_values[] = {
    -1.000000, -0.907753, -0.821362, -0.740633, -0.665375, -0.595396, 
    -0.530504, -0.470508, -0.415214, -0.364431, -0.317968, -0.275632, 
    -0.237231, -0.202574, -0.171468, -0.143721, -0.119142, -0.097538, 
    -0.078717, -0.062488, -0.048659, -0.037037, -0.027431, -0.019648, 
    -0.013497, -0.008786, -0.005323, -0.002915, -0.001372, -0.000005, 
    -0.000108,    -4e-06,     4e-06,  0.000108,    0.0005,  0.001372, 
     0.002915,  0.005323,  0.008786,  0.013497,  0.019648,  0.027431, 
     0.037037,  0.048659,  0.062488,  0.078717,  0.097538,  0.119142, 
     0.143721,  0.171468,  0.202574,  0.237231,  0.275632,  0.317968, 
     0.364431,  0.415214,  0.470508,  0.530504,  0.595396,  0.665375, 
     0.740633,  0.821362,  0.907753,  1.0};

  float skew = 0.0;
  for(int k = 0; k < HISTOGRAM_BIN_COUNT; k++){
    skew += zk_values[k] * histogram->bins[k];
  }

  // Normnalization [3]
  stats -> skewness = skew * inv_pix_size;
}





// ---------------------------------- AE / AGC ------------------------------

uint8_t AE_control_exposure(
    statistics_t* global_stats,
    chanend c_control)
{
  // Initial exposure
  static uint8_t new_exp = AE_INITIAL_EXPOSURE;
  static uint8_t skip_ae_control = 0; // if too dark for a ceertain frames, skip AE control

  // Compute skewness and adjust exposure if needed
  float sk = AE_compute_mean_skewness(global_stats);
  if (AE_is_adjusted(sk)) {
    return 1;
  } else {
    // Adjust exposure
    new_exp = AE_compute_new_exposure((float)new_exp, sk);
    // Send new exposure
    uint32_t encoded_cmd = ENCODE(SENSOR_SET_EXPOSURE, new_exp);
    chan_out_word(c_control, encoded_cmd);
    chan_in_word(c_control);
    // Skip AE control if too dark
    if (new_exp > 70) {
      skip_ae_control++;
      if (skip_ae_control > 5) {
        skip_ae_control = 0;
        return 1;
      }
    }
  }
  return 0;
}

inline uint8_t AE_is_adjusted(float sk) {
  return (sk < AE_MARGIN && sk > -AE_MARGIN) ? 1 : 0;
}

float AE_compute_mean_skewness(statistics_t *stats){
  float mean = \
    stats->stats_red.skewness + \
    stats->stats_green.skewness + \
    stats->stats_blue.skewness;
  mean /= 3.0;
  return mean;
}

static
int8_t csign(float x) {
  return (x > 0) - (x < 0);
}

uint8_t AE_compute_new_exposure(float exposure, float skewness)
{
  static float a  = 0;     // minimum value for exposure
  static float fa = -1;   // minimimum skewness
  static float b  = 80;    // maximum value for exposure
  static float fb = 1;    // minimum skewness
  static int count = 0;
  float c  = exposure;
  float fc = skewness;

  if(csign(fc) == csign(fa)){
    a = c; fa = fc;
  }
  else{
    b = c; fb = fc;
  }
  c  = b - fb*((b - a)/(fb - fa));

  // each X samples, restart AE algorithm
  if (count < 5){
    count = count + 1;
  }
  else{
    // restart auto exposure
    count = 0; a = 0; fa = -1; b = 80; fb = 1;    
  }
  return c;
}


// ---------------------------------- AWB ------------------------------

void AWB_compute_gains_static(isp_params_t *isp_params){
  isp_params->channel_gain[0] = AWB_gain_RED;
  isp_params->channel_gain[1] = AWB_gain_GREEN;
  isp_params->channel_gain[2] = AWB_gain_BLUE;
}


// ---------------------------------- GAMMA ------------------------------

// gamma 1.8, with substract 10 and 1.05 multiplier
const uint8_t gamma_uint8[256] = {
0,   0,   0,   0,   0,   0,   0,   2,   5,   8,  11,  14,  16,
19,  21,  23,  26,  28,  30,  32,  34,  36,  38,  40,  42,  43,
45,  47,  49,  50,  52,  54,  55,  57,  59,  60,  62,  63,  65,
66,  68,  69,  71,  72,  73,  75,  76,  77,  79,  80,  82,  83,
84,  85,  87,  88,  89,  91,  92,  93,  94,  95,  97,  98,  99,
100, 101, 103, 104, 105, 106, 107, 108, 109, 110, 112, 113, 114,
115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
128, 130, 131, 132, 133, 134, 134, 135, 136, 137, 138, 139, 140,
141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 152,
153, 154, 155, 156, 157, 158, 159, 160, 161, 161, 162, 163, 164,
165, 166, 167, 167, 168, 169, 170, 171, 172, 173, 173, 174, 175,
176, 177, 178, 178, 179, 180, 181, 182, 182, 183, 184, 185, 186,
186, 187, 188, 189, 190, 190, 191, 192, 193, 194, 194, 195, 196,
197, 197, 198, 199, 200, 200, 201, 202, 203, 203, 204, 205, 206,
206, 207, 208, 209, 209, 210, 211, 212, 212, 213, 214, 215, 215,
216, 217, 217, 218, 219, 220, 220, 221, 222, 222, 223, 224, 225,
225, 226, 227, 227, 228, 229, 229, 230, 231, 232, 232, 233, 234,
234, 235, 236, 236, 237, 238, 238, 239, 240, 240, 241, 242, 242,
243, 244, 244, 245, 246, 246, 247, 248, 248, 249, 250, 250, 251,
252, 252, 253, 254, 254, 255, 255, 255, 255};

// gamma 1.8, with substract 10 and 1.05 multiplier (int8 version)
const int8_t gamma_int8[256] = {
-128,-128,-128,-128,-128,-128,-128,-126,-123,-120,-117,-114,-112,-109,-107,-105,
-102,-100,-98, -96, -94, -92, -90, -88, -86, -85, -83, -81, -79, -78, -76, -74,
-73, -71, -69, -68, -66, -65, -63, -62, -60, -59, -57, -56, -55, -53, -52, -51,
-49, -48, -46, -45, -44, -43, -41, -40, -39, -37, -36, -35, -34, -33, -31, -30,
-29, -28, -27, -25, -24, -23, -22, -21, -20, -19, -18, -16, -15, -14, -13, -12,
-11, -10, -9,  -8,  -7,  -6,  -5,  -4,  -3,  -2,  -1,  0,2,3,4,5,
6,6,7,8,9,10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,
21,  22,  23,  24,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  33,  34,
35,  36,  37,  38,  39,  39,  40,  41,  42,  43,  44,  45,  45,  46,  47,  48,
49,  50,  50,  51,  52,  53,  54,  54,  55,  56,  57,  58,  58,  59,  60,  61,
62,  62,  63,  64,  65,  66,  66,  67,  68,  69,  69,  70,  71,  72,  72,  73,
74,  75,  75,  76,  77,  78,  78,  79,  80,  81,  81,  82,  83,  84,  84,  85,
86,  87,  87,  88,  89,  89,  90,  91,  92,  92,  93,  94,  94,  95,  96,  97,
97,  98,  99,  99,  100, 101, 101, 102, 103, 104, 104, 105, 106, 106, 107, 108,
108, 109, 110, 110, 111, 112, 112, 113, 114, 114, 115, 116, 116, 117, 118, 118,
119, 120, 120, 121, 122, 122, 123, 124, 124, 125, 126, 126, 127, 127, 127, 127,
};

void isp_gamma(
  uint8_t * img_in,
  const uint8_t *gamma_curve,
  const size_t height, 
  const size_t width, 
  const size_t channels)
{
  xassert((gamma_curve[255] != 0) && "Gamma curve is not filled correctly"); // ensure all values are filles up
  size_t buffsize = height * width * channels;
  for(size_t idx = 0; idx < buffsize; idx++){
      img_in[idx] = gamma_curve[img_in[idx]];
  }
}
